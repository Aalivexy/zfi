use fatfs::{FileSystem, FormatVolumeOptions, FsOptions};
use gpt::disk::LogicalBlockSize;
use gpt::mbr::ProtectiveMBR;
use gpt::partition_types::EFI;
use gpt::GptConfig;
use serde::Deserialize;
use std::collections::{BTreeMap, HashMap};
use std::fs::{create_dir_all, File};
use std::io::{BufRead, BufReader, Cursor};
use std::ops::{Deref, DerefMut};
use std::path::Path;
use std::process::{Child, Command, Stdio};

/// Run the project that was generated by [`qemu`] attribute.
pub fn run_qemu_test<P: AsRef<Path>>(root: P) {
    let root = root.as_ref();

    // Load the config.
    let config = std::fs::read_to_string("zfi.toml")
        .expect("cannot read zfi.toml on the root of the package");
    let config = toml::from_str::<Config>(&config)
        .expect("cannot parse zfi.toml on the root of the package")
        .qemu;

    for (target, qemu) in config {
        run_test(root, &target, &qemu);
    }
}

fn run_test(root: &Path, target: &str, config: &QemuConfig) {
    // Build the project.
    let project = root.join("project");
    let status = Command::new("cargo")
        .current_dir(&project)
        .arg("install")
        .args(["--target", target])
        .args(["--path", "."])
        .args(["--root", "."])
        .arg("--debug")
        .arg("--quiet")
        .stdin(Stdio::null())
        .status()
        .expect(&format!(
            "cannot spawn cargo on {} for {} target",
            project.display(),
            target
        ));

    if !status.success() {
        panic!(
            "build {} for {} was failed with {}",
            project.display(),
            target,
            status
        );
    }

    // Get ptoject name.
    let name = std::fs::read_to_string(project.join("Cargo.toml"))
        .expect(&format!(
            "cannot read Cargo.toml from {}",
            project.display()
        ))
        .parse::<toml::Table>()
        .expect(&format!("cannot parse Cargo.toml on {}", project.display()))
        .get("package")
        .unwrap()
        .as_table()
        .unwrap()
        .get("name")
        .unwrap()
        .as_str()
        .unwrap()
        .to_owned();

    // Get path to the binary.
    let mut bin = project.join("bin");

    bin.push(name);
    bin.set_extension("efi");

    // Create a VM disk.
    let size = 512 * 2048 * 2;
    let mut disk = Cursor::new(vec![0; size]);

    ProtectiveMBR::with_lb_size(u32::try_from((size / 512) - 1).unwrap_or(0xFFFFFFFF))
        .overwrite_lba0(&mut disk)
        .expect("cannot write MBR");

    // Create a GPT.
    let mut gpt = GptConfig::new()
        .initialized(false)
        .writable(true)
        .create_from_device(Box::new(&mut disk), None)
        .expect("cannot create a GPT");

    gpt.update_partitions(BTreeMap::new())
        .expect("cannot initialize the GTP");

    // Create EFI partition.
    let part = gpt
        .add_partition("zfi", 512 * 2048, EFI, 0, None)
        .expect("cannot create an EFI system partition");
    let part = gpt.partitions().get(&part).unwrap();
    let offset: usize = part
        .bytes_start(LogicalBlockSize::Lb512)
        .unwrap()
        .try_into()
        .unwrap();
    let size: usize = part
        .bytes_len(LogicalBlockSize::Lb512)
        .unwrap()
        .try_into()
        .unwrap();

    gpt.write().unwrap();

    // Format EFI partition.
    let mut data = disk.into_inner();

    fatfs::format_volume(
        Cursor::new(&mut data[offset..(offset + size)]),
        FormatVolumeOptions::new(),
    )
    .expect("cannot format EFI system partition");

    // Put binary to EFI/boot.
    std::io::copy(
        &mut File::open(&bin).unwrap(),
        &mut FileSystem::new(
            Cursor::new(&mut data[offset..(offset + size)]),
            FsOptions::new(),
        )
        .unwrap()
        .root_dir()
        .create_dir("EFI")
        .unwrap()
        .create_dir("boot")
        .unwrap()
        .create_file(match target {
            "x86_64-unknown-uefi" => "bootx64.efi",
            v => todo!("target {v}"),
        })
        .unwrap(),
    )
    .expect(&format!(
        "cannot put {} to the EFI system partition",
        bin.display()
    ));

    // Create a VM directory.
    let vm = root.join("vm");

    create_dir_all(&vm).expect(&format!("cannot create {}", vm.display()));

    // Write the disk.
    let disk = vm.join("disk.img");

    std::fs::write(&disk, &data).expect(&format!("cannot create {}", disk.display()));

    // Copy UEFI NVRAM.
    let nvram = vm.join("nvram.fd");

    std::fs::copy(&config.nvram, &nvram).expect(&format!(
        "cannot copy {} to {}",
        config.nvram,
        vm.display()
    ));

    // Spawn QEMU.
    let qemu = Command::new(&config.bin)
        .stdin(Stdio::null())
        .stdout(Stdio::piped())
        .stderr(Stdio::null())
        .arg("-nographic")
        .arg("-drive")
        .arg(format!(
            "if=pflash,format=raw,readonly=on,file={}",
            config.firmware
        ))
        .arg("-drive")
        .arg(format!(
            "if=pflash,format=raw,file={}",
            nvram.to_str().unwrap()
        ))
        .arg("-drive")
        .arg(format!(
            "if=virtio,format=raw,file={}",
            disk.to_str().unwrap()
        ))
        .spawn()
        .expect(&format!("cannot spawn {}", config.bin));
    let mut qemu = Qemu(qemu);

    // Read our command.
    let mut stdout = BufReader::new(qemu.stdout.take().unwrap());
    let mut line = String::new();

    loop {
        // Read the line.
        line.clear();

        if stdout
            .read_line(&mut line)
            .expect("cannot read QEMU output")
            == 0
        {
            panic!("the communication with QEMU was closed");
        }

        // Parse the command.
        let (cmd, _) = if !line.starts_with("zfi:") {
            continue;
        } else {
            let data = &line[4..];

            match data.split_once(':') {
                Some((l, r)) => (l, r.trim_end()),
                None => (data.trim_end(), ""),
            }
        };

        // Process the command.
        match cmd {
            "ok" => break,
            v => panic!("unknown command '{v}' from QEMU"),
        }
    }
}

#[derive(Deserialize)]
struct Config {
    qemu: HashMap<String, QemuConfig>,
}

#[derive(Deserialize)]
struct QemuConfig {
    bin: String,
    firmware: String,
    nvram: String,
}

struct Qemu(Child);

impl Drop for Qemu {
    fn drop(&mut self) {
        let _ = self.0.kill();
        let _ = self.0.wait();
    }
}

impl Deref for Qemu {
    type Target = Child;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl DerefMut for Qemu {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
