use proc_macro2::{Ident, TokenStream};
use quote::{quote, quote_spanned};
use syn::{Error, ItemFn, LitStr};

pub fn parse_entry(entry: ItemFn, options: EntryOptions) -> Result<TokenStream, Error> {
    // Get debug writer.
    let debug = match options.debug {
        Some(v) => match v {
            EntryDebug::Extension(v) => {
                let span = v.span();

                quote_spanned! {span=>
                    Some(|| ::alloc::boxed::Box::new(::zfi::DebugFile::next_to_image(#v).unwrap()))
                }
            }
            EntryDebug::Writer(v) => {
                let span = v.span();

                quote_spanned!(span=> Some(#v))
            }
        },
        None => quote!(None),
    };

    // Get panic handler.
    let panic = if options.no_ph {
        TokenStream::new()
    } else {
        quote! {
            /// A panic handler that was generated by `zfi::main` macro.
            #[cfg(not(test))]
            #[panic_handler]
            fn panic_handler(info: &::core::panic::PanicInfo) -> ! {
                ::zfi::eprintln!("{info}");
                loop {}
            }
        }
    };

    // Compose fragments.
    let name = &entry.sig.ident;

    Ok(quote! {
        extern crate alloc;

        /// The real entry point that was generated by `zfi::main` macro.
        #[no_mangle]
        extern "efiapi" fn efi_main(
            image: &'static ::zfi::Image,
            st: &'static ::zfi::SystemTable,
        ) -> ::zfi::Status {
            let f: fn() -> ::zfi::Status = #name;
            unsafe { ::zfi::init(image, st, #debug) };
            f()
        }

        #entry

        #panic

        /// A global allocator that was generated by `zfi::main` macro.
        #[cfg(not(test))]
        #[global_allocator]
        static ALLOCATOR: ::zfi::PoolAllocator = ::zfi::PoolAllocator;
    })
}

#[derive(Default)]
pub struct EntryOptions {
    pub debug: Option<EntryDebug>,
    pub no_ph: bool,
}

pub enum EntryDebug {
    Extension(LitStr),
    Writer(Ident),
}
